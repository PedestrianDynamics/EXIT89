subroutine readcsv(iunit, x, c, numr, numc, nstart, maxr, maxc)
!======================================================================
! Reads a comma-delimited file as generated by Microsoft Excel
!
! Input Parameters:
!   iunit  - Logical unit number, must be already open to .csv file
!   numr   - Maximum number of rows in arrays x and c
!   numc   - Maximum number of columns in arrays x and c
!   nstart - Starting row of spreadsheet to read (skip nstart-1 rows)
!
! Output Parameters:
!   x      - Real array(numr,numc) containing numeric values
!   c      - Character array(numr,numc) containing original strings
!   maxr   - Actual number of rows read
!   maxc   - Maximum number of columns found in any row
!
! Note: The routine assumes all data can be converted to real numbers.
!       Non-numeric data will be stored as 0.0 in array x.
!======================================================================
   implicit none

   ! Arguments
   integer, intent(in)    :: iunit, numr, numc, nstart
   integer, intent(out)   :: maxr, maxc
   real, intent(out)      :: x(numr, numc)
   character(*), intent(out) :: c(numr, numc)

   ! Local variables
   character(len=10000) :: in
   character(len=100)   :: token
   integer :: i, j, nr, nc, ic, icomma, ios
   logical :: eof

   ! Initialize arrays and counters
   x = 0.0
   c = ' '
   maxr = 0
   maxc = 0

   ! Skip header rows if requested
   if (nstart > 1) then
      do i = 1, nstart - 1
         read (iunit, '(A)', iostat=ios) in
         if (ios /= 0) then
            write (*, '(A,I0)') 'Error: Unable to skip headers. iostat=', ios
            return
         end if
      end do
   end if

   ! Main reading loop
   nr = 0
   read_loop: do
      read (iunit, '(A)', iostat=ios) in
      if (ios /= 0) exit read_loop

      nr = nr + 1
      if (nr > numr) then
         write (*, '(A,I0)') 'Error: Maximum rows exceeded: ', numr
         return
      end if

      maxr = max(maxr, nr)
      nc = 0
      ic = 1

      ! Process each field in the current line
      parse_line: do
         icomma = index(in(ic:), ',')

         if (icomma == 0) then
            ! Last field in line
            nc = nc + 1
            if (nc > numc) then
               write (*, '(A,I0,A,I0)') 'Error: Maximum columns exceeded at row ', nr, ', column ', nc
               return
            end if

            token = adjustl(in(ic:))
            c(nr, nc) = token
            read (token, '(f100.0)', iostat=ios) x(nr, nc)
            if (ios /= 0) x(nr, nc) = 0.0
            exit parse_line
         else
            ! Field with following comma
            nc = nc + 1
            if (nc > numc) then
               write (*, '(A,I0,A,I0)') 'Error: Maximum columns exceeded at row ', nr, ', column ', nc
               return
            end if

            if (icomma == 1) then
               token = ' '
            else
               token = in(ic:ic + icomma - 2)
            end if

            c(nr, nc) = adjustl(token)
            read (token, '(f100.0)', iostat=ios) x(nr, nc)
            if (ios /= 0) x(nr, nc) = 0.0

            ic = ic + icomma
         end if
      end do parse_line

      maxc = max(maxc, nc)
   end do read_loop

end subroutine readcsv
